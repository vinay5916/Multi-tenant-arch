# executors/base_executor.py
import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Any, Dict, AsyncGenerator, AsyncIterable, Optional, List
from uuid import uuid4
import json
from datetime import datetime

# Import LiteLLM for Ollama integration
import litellm

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Configure LiteLLM
litellm.set_verbose = False


class TaskState:
    """Task states for the agent execution"""
    PENDING = "pending"
    WORKING = "working"
    COMPLETED = "completed"
    FAILED = "failed"


class TaskStatus:
    """Task status representation"""
    def __init__(self, state: str, message: str = "", progress: float = 0.0):
        self.state = state
        self.message = message
        self.progress = progress
        self.timestamp = datetime.now()


class Artifact:
    """Agent execution artifact"""
    def __init__(self, content: Any, artifact_type: str = "text", metadata: Dict[str, Any] = None):
        self.content = content
        self.artifact_type = artifact_type
        self.metadata = metadata or {}
        self.created_at = datetime.now()


class RequestContext:
    """Context for agent execution requests"""
    def __init__(self, 
                 task_id: str, 
                 context_id: str, 
                 user_message: str,
                 tenant_id: str = "default",
                 user_id: str = "system"):
        self.task_id = task_id
        self.context_id = context_id
        self.user_message = user_message
        self.tenant_id = tenant_id
        self.user_id = user_id
        self.created_at = datetime.now()


class TaskUpdater:
    """Updates task status and manages artifacts"""
    def __init__(self, task_id: str, context_id: str):
        self.task_id = task_id
        self.context_id = context_id
        self.artifacts = []
        self.status_history = []
        
    def update_status(self, state: str, message: str = "", progress: float = 0.0):
        """Update task status"""
        status = TaskStatus(state, message, progress)
        self.status_history.append(status)
        logger.debug(f"Task {self.task_id} status updated: {state} - {message}")
        
    def add_artifact(self, content: Any, artifact_type: str = "text", metadata: Dict[str, Any] = None):
        """Add artifact to task"""
        artifact = Artifact(content, artifact_type, metadata)
        self.artifacts.append(artifact)
        logger.debug(f"Artifact added to task {self.task_id}: {artifact_type}")
        
    def complete(self):
        """Mark task as completed"""
        self.update_status(TaskState.COMPLETED, "Task completed successfully", 100.0)
        
    def fail(self, error_message: str):
        """Mark task as failed"""
        self.update_status(TaskState.FAILED, error_message, 0.0)


class BaseAgentExecutor(ABC):
    """Base abstract class for all agent executors following mas-a2a pattern"""
    
    def __init__(self, agent_name: str, agent_type: str, system_prompt: str, model: str = "llama3.2"):
        self.agent_name = agent_name
        self.agent_type = agent_type  
        self.system_prompt = system_prompt
        self.model = f"ollama/{model}"
        self.sessions = {}  # In-memory session storage
        
    @abstractmethod
    async def execute_task(self, context: RequestContext, task_updater: TaskUpdater) -> AsyncIterable[TaskStatus | Artifact]:
        """Execute the main agent task - must be implemented by subclasses"""
        pass
        
    async def execute(self, context: RequestContext) -> Dict[str, Any]:
        """Main execution method that coordinates the agent's work"""
        task_updater = TaskUpdater(context.task_id, context.context_id)
        
        try:
            # Start the task
            task_updater.update_status(TaskState.WORKING, f"Starting {self.agent_name} execution")
            
            # Execute the specific agent task
            async for result in self.execute_task(context, task_updater):
                if isinstance(result, TaskStatus):
                    logger.debug(f"Status update for {self.agent_name}: {result.message}")
                elif isinstance(result, Artifact):
                    logger.debug(f"Artifact generated by {self.agent_name}: {result.artifact_type}")
                    
            # Return the final result
            return {
                "task_id": context.task_id,
                "agent_name": self.agent_name,
                "status": "completed",
                "artifacts": [{"content": art.content, "type": art.artifact_type, "metadata": art.metadata} 
                             for art in task_updater.artifacts],
                "execution_time": (datetime.now() - context.created_at).total_seconds()
            }
            
        except Exception as e:
            logger.error(f"Error in {self.agent_name} execution: {str(e)}")
            task_updater.fail(f"Execution failed: {str(e)}")
            return {
                "task_id": context.task_id,
                "agent_name": self.agent_name,
                "status": "failed",
                "error": str(e),
                "execution_time": (datetime.now() - context.created_at).total_seconds()
            }
    
    async def _call_llm(self, user_message: str, context: Dict[str, Any] = None) -> str:
        """Call the LLM with the agent's system prompt"""
        try:
            messages = [
                {"role": "system", "content": self.system_prompt},
                {"role": "user", "content": user_message}
            ]
            
            # Add context if provided
            if context:
                context_str = f"Additional context: {json.dumps(context, default=str)}"
                messages.insert(-1, {"role": "assistant", "content": context_str})
            
            response = await litellm.acompletion(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=1500
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            logger.error(f"LLM call failed for {self.agent_name}: {str(e)}")
            return f"I apologize, but I'm experiencing technical difficulties. Error: {str(e)}"
    
    async def _get_session(self, session_id: str) -> Dict[str, Any]:
        """Get or create session"""
        if session_id not in self.sessions:
            self.sessions[session_id] = {
                "id": session_id,
                "created_at": datetime.now(),
                "messages": [],
                "context": {}
            }
        return self.sessions[session_id]
    
    async def _use_tools(self, tool_calls: List[Dict[str, Any]], context: RequestContext) -> List[Dict[str, Any]]:
        """Execute tool calls - to be overridden by specific agents with tools"""
        logger.warning(f"Agent {self.agent_name} does not implement tool usage")
        return []